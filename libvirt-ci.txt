
Redhat Beaker Usage
===================

1. set beaker env
    - reference page
        https://docs.engineering.redhat.com/display/HTD/beaker.engineering.redhat.com+User+Guide
    - download internal beaker repo file
        #curl -o /etc/yum.repos.d/beaker-client.repo https://download.eng.bos.redhat.com/beakerrepos/beaker-client-RedHatEnterpriseLinux.repo
    - install packages
        #yum install beaker-client beaker-redhat
    - registration in beaker with Kerberos password
        #kinit jil@REDHAT.COM
    - Verify that the bkr command works
        #bkr whoami
        {'username': 'dcallagh', 'email_address': 'dcallagh@redhat.com'}
















1. create a jenkins public key in target server
[root@rhel7 ~]# cat .ssh/authorized_keys
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAnDTpLaJrrmEyYpT0BkAIOI/7ym46gaQJRykdV5FHyft8ejA18sL3IHRpO2lrsCFGfEj5U+VuxePKwvsnhbBHlXHmpcYKYuo8AmlUwNLGjGXqHNtsP5qjurSBhPycJaA/Q4ZDMwb/PGoPABVoRnyM+J0E9XIT3TTz3TL2BBpR+gAGs/CaNpi4DtkNWCHSr/HFBXp6FbZBjjRr7HLIlv/GyTxlb/SnLxeLX1TnYK7DS32oUIj2NdFWxDQ/jn983Eluwc7WYi+ZvdjEoEI7b1VDHR3uNuHDU3VZNCheTswPRNnl2wcAC3AevAsCHS6HPSMM0nfkWvzOYl2Ro8PvXdi4Dw==

2. log in jenkins web page to trig a jenkins job to install libvirt-ci environment
    - login jenkins single-provision page and configure the jenkins task
    https://libvirt-jenkins.rhev-ci-vms.eng.rdu2.redhat.com/job/single-provision/
    id: jil
    passwd: kerberos passwd
    
    - configure the single provision page to launch the setting of libvirt-ci env job
        click "Build with Parameters"
        fill out the form as follows:
            TARGET_SLAVE jil_rhel7/rhel8
            LIBVIRT_CI_BRANCH master
            PROVISION_TARGET bkr/10.66.5.24
            PROVISION_VERSION 7.6/8.0
            PROVISION_PRODUCT RHEL
            PROVISION_VIRT_MODULE_STREAM rhel/8.0.0

3. rerun failed Jenkins testrun in the provisioned machine

    - select a JIRA issue and open Jenkins log via Jenkin link in the comment of JIRA issue
    - copy the Jenkins job and change the following parameters:
        NODE_LABEL jil_rhel8
        CI_ONLY



key concepts about Libvirt CI
----------------------------

RHEL6 qemu-kvm
RHEL7 qemu-kvm/qemu-kvm-rhev
RHEL8 qemu-kvm on slow train/fast train

https://gitlab.cee.redhat.com/libvirt-auto/libvirt-ci.git



config/blacklist.yaml
config/jobs.yaml





Red Hat Enterprise Linux
------------------------

8.0.1 TES 6.12 - 7.23

8.1.0 DEV/TES 2.13 - 9.11



Red Hat Enterprise Linux Advanced Virtualization
------------------------------------------------
Red Hat Enterprise Linux Advanced Virtualization is one of the technologies that enables Red Hatâ€™s virtualization products:
    Red Hat OpenStack, Container Network Virtualization and Red Hat Virtualization

RHEL-AV 8.0.1 - TES 6.12 - 7.12

RHEL-AV 8.1.0 - DEV/TES 5.16 - 8.14
              - TES 9.3 - 11.6

datagrepper - for tree message
    https://datagrepper.engineering.redhat.com/raw?topic=/topic/VirtualTopic.eng.rtt.ci
    RTT  - release test team
    - job-trigger --> image build
    - send email


brew-watcher
    - MBS
    https://mbs.engineering.redhat.com/module-build-service/1/module-builds/?name=virt
        - repo-updater
            - build private repo
            - send mail
            - send message to job-trigger
        - gating job
            - job-trigger

osci dashboard - http://dashboard.osci.redhat.com/#/search/redhat-modules

gating
    - libvirt libvirt-python
    - module

beaker
    - beaker python2.6 
    - 

PSI - US
    - openshift
    - openstack

openshift - OCP - beijing
    - metadash
    - jenkins node




jenkins
-------

provision + runtest + teardown

1. jenkins provision job workflow




metadash beaker checksum



Libvirt-ci Good Practice
------------------------
1. add usb test run into libvirt jobs
    in libvirt-ci/config/jobs.yaml
        a. add job name
        jobs:
            libvirt:
                function:
                    usb
        b. only schedule usb test on x86 arch
        - when: test.startswith('libvirt.function.usb')
          exclude:
              - arch == 's390x'
              - arch == 'ppc64le'
              - arch == 'aarch64'
        c. only schedule usb test on a dedicated machine for usb case
        - when: test.startswith('libvirt.function.usb')
          location: 'dell-per740-08.lab.eng.pek2.redhat.com'
          only: |
              usb_device.passthrough.vid_pid
              usb_device.passthrough.bus_dev
              usb_device.redirdev.spicevmc
              usb_device.redirdev.tcp
          feature: 'usb'
    in job_trigger/config/jobs.yaml
        a. add job name
        jobs:
            libvirt:
                function:
                    usb
        b. only schedule usb test on x86 arch
        - when: test.startswith('libvirt.function.usb')
          exclude:
              - arch == 's390x'
              - arch == 'ppc64le'
              - arch == 'aarch64'
    in job_trigger/job_trigger.py
        a. Do not trigger job in backend, so add into _validate_job
        def _validate_job
            if job['job_data']['job_name'] in ['function-usb']

2. add a jenkins job parameter - PROVISION_VIRT_MODULE_NAME
-----------------------------------------------------------

step one: change data file
----------------------------
    1. add jenkins parameter provision-virt-module-name
    in libvirt_ci/data/jobs/macros/common/parameters.yaml
    - parameter:
      name: provision-virt-module-name
      parameters:
        - string:
            name: PROVISION_VIRT_MODULE_NAME
            default: '{default}'
            description: |
                RHEL-8 virt module name selection
    - parameter:
      name: provision
      parameters:
      ...
        - provision-virt-module-name:
            default: '{provision-virt-module-name}'

    2. set the parameter of provision job
    in libvirt_ci/data/jobs/provision.yaml
    parameters:
        - provision:
            provision-virt-module-name: '{virt_module_name}'

    3. set the parameter of image build job
    in libvirt_ci/data/jobs/image_builder.yaml
    - job-group:
        virt_module_name: ''
    
    4. set the parameter of package build job
    in libvirt_ci/data/jobs/package_builder.yaml
    - job-group:
        virt_module_name: ''

    5. change the shell cmd to install & enable virt module
    in libvirt_ci/data/kickstarts/guest-RHEL-8.cfg

step two: change config file
    1. provision job parameter
    in libvirt_ci/config/jobs.yaml
    # Provision related default parameters
    - 
      virt_module_name:''


step three: change command file

    1. change the way to create module repo
    in libvirt_ci/yum_repos.py
    def generate_virt_module_repo

    2. add module_name to provision task
    in libvirt_ci/commands/provision.py
        -  use module stream and name to generate virt module repo
        -  add module name as parameters of test_env_group


3. How a parameter in jenkins job is defined and used?

    1. config/jobs.yaml, end user set the value of "Test runner related default parameters" and "jobs related parameters"
    2. ./data/jobs/provision.yaml + config/jobs.yaml --> jenkins job parameter 

    3. JJB use jenkins job parameter + ./data/jobs/macros/common/parameters.yaml --> every jenkins job

    4. when jenkins job is scheduled to run, the jenkins job parameter is set to env

    5. command file(e.g. provision.py or beaker.py) deal with the system env and default parameters and run task


4. minimal available message

{"product": "RHEL", "bkr_info": {"distro_tags": ["RTT_PASSED", "RTT_PASSED_PRIMARY"], "distro_name": "RHEL-8.0.1-updates-20190709.0"}, "arches": ["aarch64", "x86_64", "s390x", "ppc64le"], "version": "8.0", "build": "RHEL-8.0.1-updates-20190709.0"}


5. Libvirt CI microservice main tasks list:
    brew watcher/scan_modules
        _scan_new_module
        1. based on module name and stream name, such as {'name':'virt', 'stream':'8.1'}, scan MBS to to get newly(not listed in libvirt CI metadata) arrived virt module info
        2. ignore module if it has been listed in libvirt ci-metadata
        3. ACTION pass "gating" job to job-trigger/trigger_job service if new virt module arrived
        4. ACTION get all the params for service RepoUpdaterService /repo/update-module
            - name, module name
            - version, product version such as RHEL7.8/RHEL8.0/RHEL8.0.0/RHEL8.1
            - pkgs, the pkg list in module, virt module package nvr list based on cmd "brew latest-build --all --quiet module_name"
            - typ, module type such as virt
            - stream, module stream
            - platform, platform stream from module info such as el8.0.1/el8.0.0z/el8.1.0
            - mbs_id, module mbs id
        5. send request to service RepoUpdaterService /repo/update-module

    brew watcher/scan_latest_pkgs
        __check_packages_status
        0. get packages list that members and groups are watching
        1. get the "Brew Tag List", aka BTL of the current product
        2. from brew, based on the BTL, get dict {nvr, (pkg, tag)} of latest build, including every packages
        3. filter the package list to be updated: recorded_packages vs latest_packages
        3. send the data of package that need updating to RepoUpdaterService /repo/update-pkg/header
        package data:


    repo-updater service init
    1. repo-updater/run
        analyse the default params and run prepare(params)
    2. prepare(params)
        set jenkins key file
        get pkg_data and pkg_info from libvirt-ci metadata
        get the latest pkg obj of each product/pkg
    3. start service container

    repo-updater/module_update - RepoUpdaterService /repo/update-module
        1. build_module_repo
            - update module/package status
                - module
                    add module info to libvirt CI metadata if module name is NOT listed in metadata/Modules
                    change module status to working if module name is listed in metadata/Module
                - package
            - create module repo path based on product/version/module name
        2. update packages of the modules
            - collect kargs for package
            - run playbook update_custom_repo to install new packages of virt module and make virt module repo
        3. run playbook update_custom_repo
            - download package and copy to repo/archs directory
            - create repo with command createrepo_c
        4. invoke modify_module_repo
            - prepare_module_yaml:
            - run playbook build_module_repo to enable module function in repo
        5. invoke update_latest_module_repo
            - run playbook update_latest_repo to link symble latest-xxx to latest module repo
        6. update module satus in libvirt-ci metadata as done
        7. when virt module is done, notify module watcher by email
        8. invoke trigger_module_job to trigger pkg function job if core pkgs are updated
            - when stream is rhel:
                set data/"job_name" with acceptnace-xxx job
            - send data to service JobTriggerService /jobs/datas to get job name list from srvice job-trigger/get_job_datas
            job data:
                'pkg_name':pkg_name - 
                'brew_tag':version - 8.0/8.0.0/8.1
                'job_name': it is set when stream == rhel
            - filter gating jobs out of job list
            - send job list to service job-trigger/trigger_job_list
                job data:
                    message - 
                    job_data_list - 
                    params - 


    repo-updater/repo_update  RepoUpdaterService /repo/update-pkg/header
    1. invoke update_repo_internal
        - get base_repo_path: /srv/www/html/libvirt-CI-repos
        - if the pkg is scratch build
            if the pkg is not libvirt or qemu-kvm, return
            if the pkg is libvirt and "cov" is in pkg's "release" name
                base_repo_path = /srv/www/html/libvirt-CI-Coverage-repos
        - based on brew_tag and trigger_pacagke, get (product,version) from libvirt metadata
        - based on new pkg info to filter out a existing pkg from libvirt metadata
            if there is record in libvirt metadata, add a repo path for product/version
        - update_single_pkgs
            invoke update_packages with pkg args and repolist
            run playbook update_custom_repo



    job-trigger service init
    - execute bin/job-trigger --> run()
    - prepare_date(cls)
        - function to create job data for each job and add all job data to cls.pkg_rules/cls.tree_rules/cls.rtt_rules based on jobs.yaml
        - analyse jobs.yaml and set
            - self._archs
            - self._products
            - self._job_ids - create a turple list of job such as [(libvirt, acceptance, gating),(libvirt, accepatance, gating_staging),...]
            - self._rules
        - generate job object and set job attribute
            - Fill the job with parameters according to the rules in jobs.yaml
            - exclude the specified jobs
        - init job name based on job name template and job date
        - init cls.pkg_rules/cls.tree_rules/cls.rtt_rules

    - init cls.job_backend





    - init container of service and start container

    job-trigger/trigger_job - service(POST, /jobs/trigger)


    job-trigger/get_job_names - service('GET', /jobs/names)
    - A rest api to get job name list with specific trigger package



    job-trigger/trigger_job_list - service('POST', /jobs/trigger-by-list)
    - 



    job-trigger/get_job_datas()
    - A rest api to get job data list with specific trigger package







libvirt-ci provision job workflow - job is created based on libvirt_ci/data/jobs/provision.yaml
---------------------------------




    1. libvirt_ci/data/jobs/scripts/setup_venv.sh
        - set up virtual env
    2. libvirt_ci/data/jobs/scripts/install_libvirt_ci.sh
        - install package libvirt-ci
    3. libvirt_ci/data/jobs/scripts/provision_slave.sh
        - run "ci provision --worker-name $jslavename"
    4. libvirt_ci/commands/provision.py
        - set up params - setup_params
            - params.yum_repos
            - params.yum_resource_repos
        - prepare repos obj - gen_recipeset_repos
            - libvirt-ci
            - libvirt_ci_virt_module
            - 

        - reserve test host
            - check params.target and params.resource_host
            - if params.target is bkr, import beaker module beaker.py as bkr
                - importer.import_module("libvirt_ci.provision.beaker")
                    - libvirt_ci/importer.py
                        - install packages via pip
                    - libvirt-ci/provision/beaker.py
                - Build a beaker job XML file based on parameters
                    - bkr.build_beaker_xml(params)
                        - 
                - Reserve host in beaker system according to beaker job XML file
                
            - if params.target is ci-osp, import osp module osp.py as osp
        - prepare ansible hosts information

        - run playbook prepare_ocp to prepare test host env

        - run playbook prepare_system to prepare test host env
            - 


    5. libvirt_ci/data/jobs/scripts/provision_slave.sh
        - save parameters from provision job



run playbook 


libvirt-ci runtest job workflow
-------------------------------
build runtest job based on libvirt_ci/data/jobs/runtest.yaml


1. all start from file libvirt_ci/commands/run.py
    - initialize env object
    - invoke env.prepare_runner and get runner of env instance
        - _process_params

2. libvirt_ci/env/__init__.py
    prepare_runner()

3. libvirt_ci/env/__init__.py
    self.config = self.param_handlers.perform_transfer(self, self.config, self.params)
        'package_handler',
        'machine_state_handler',
        'new_framework_handler',
        'git_repo_handler',
        'patches_handler',
        'test_object_handler',
        'vt_type_handler',
        '_framework_handler',
            - replace variable in cfg files of runner
            - execute runner special bootstrap

runner env handler - env/defaults.py
    - prepare_virt_module - ONLY for rhel8 and above
        prepare virt module repo file obj
            - name libvirt_ci_virt_module
            - url http://download.libvirt.redhat.com/libvirt-CI-repos/$modulename/arch/
            - priority = 2
        prepare tree repo file obj
            - $download/rhel-8/rel-eng/RHEL-8/RHEL-8.1.0-Snapshot-4.1/compose/
            - APP repo - AppStream/x86_64/os/
            - BaseOS repo - BaseOS/x86_64/os/
        run playbook prepare_virt_module
            create repo file and reset & enable virt module
    - prepare_packages
        prepare package repo file obj
            - name libvirt-coverage
            - url http://download.libvirt.redhat.com/libvirt-CI-Coverage-repos/RHEL/8.1/x86_64/'
            - priority = 2
        replace_qemu_rhev





teardown job work flow
----------------------

job teardown job --> libvirt-ci serverless teardown service --> libvirt-ci teardown service

libvirt-ci teardown service
    - scripts/setup_venv.sh
    - scripts/install_libvirt_ci.sh
    - scripts/teardown_slave.sh
    - scripts/clear_venv.sh


jobs.yaml variable meaning
--------------------------
1. module stream and module name
    - define the name of virt module  stream and when virt_module_name is provided,
      the virt module stream is set based on virt module name
    virt_module_stream
    virt_module_name
    resource_virt_module_stream
    resource_virt_module_name

2. beaker machine HW setting
    ndisk
    need_numa
    numa_nodes
    need_cpu_vendor
    need_cpu_models
    need_1g_hugepage

3. migration resource setting
    resource_virt_module_stream
    resource_virt_module_name
    resource-host
    resource-version
    resource-product
    resource-guest-name
    resource-img-dest

4. location

5. only_tree









How a job is defined:
    job_id is a list of tuple such as (libvirt, function, cpu).
    analysis the jobs.yaml and make the following rules:
        pkg_rules
        tree_rules
        rtt_rules



how to waive a gating testcase

waiverdb-cli -p rhel-7 -r 2432608 -c "script issue"


lbivirt-ci/run.py
-----------------
    1.    get params and extra_params from os.envion







The smallest message:

 {"product": "RHEL", "bkr_info": {"distro_tags": ["RTT_PASSED", "RTT_PASSED_PRIMARY"], "distro_name": "RHEL-8.0.1-updates-20190709.0"}, "arches": ["aarch64", "x86_64", "s390x", "ppc64le"], "version": "8.0", "build": "RHEL-8.0.1-updates-20190709.0"}


libvirt-ci jenkins job related failure and solution(junxiang)

1. packages and virt module
    The packages in watching by people and group of libvirt metadata will be in kepted in libvirt-ci repo and updated timely
    Module stream, module name and module id
        virt:8.0.0
        virt:8.0
        virt:8.1
        virt:rhel


libvirt-ci FAQ
--------------

1. RHEL product and repo installation
    available repo resource:
        1. 



    scenario one:
    scenario two:
    scenario three:



Jenkins job FAQ
---------------

    1. Network issue
    - <urlopen error [Errno -2] Name or service not known>
        - DNS service failure
    - TASK [Prepare required rpm packages on RHEL8 or Fedora] failed:
        - github access issue
    - HTTPSConnectionPool(host='files.pythonhosted.org', port=443): Read timed out
        - GWF issue
    2. some package requires higher version python. need to lock up the package to old version
    - requests-oauthlib requires Python '>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*' but the running Python is 2.6.6
    3. The latest A package depends on the latest B package, but B package is not in watch list
    - nothing provides libseccomp >= 2.4.0 needed by qemu-kvm-core-15:2.12.0-77.module+el8.1.0+3382+49219945.ppc64le
    4. Google ban the ip so jenkins could not get the info from libvirt-ci metadata
    - frequent google sheet access cause the google ban the ci IP
        Refreshing access_token
        Build was aborted
        or
        Error when 'get_all_values' google sheet 'Products':















weekly meeting call for libvirt-ci daily task QA
1. Testing environment issue
    Tree -
    Repo - 
    Guest vm image name
        - RHOS platform project-->computer-->instances click "launch instance"
          Source-->available name:8.1


2. 



{"product": "RHEL", "bkr_info": {"distro_tags": ["RTT_PASSED", "RTT_PASSED_PRIMARY"], "distro_name": "RHEL-7.8-20191009.6"}, "arches": ["aarch64", "x86_64", "s390x", "ppc64le"], "version": "7.8", "build": "RHEL-7.8-20191009.6"}


 {"product": "RHEL", "bkr_info": {"distro_tags": ["RC-1.1"], "distro_name": "RHEL-8.1.0-20191015.0"}, "arches": ["aarch64", "x86_64", "s390x", "ppc64le"], "version": "8.1", "build": "RHEL-8.1.0-20191015.0"}
